---
title: "Introduction to plotting"
---

```{r}
#| echo: false
#| message: false
#| results: hide
source(file = "setup-files/setup.R")
```

```{python}
#| echo: false
#| message: false
import shutup;shutup.please()
exec(open('setup-files/setup.py').read())
```

::: {.callout-tip}
## Learning outcomes

- Be able to create basic plots

:::

## Libraries and functions

::: {.callout-note collapse="true"}
## Click to expand

::: {.panel-tabset group="language"}
## R

### Libraries
### Functions

:::
:::

## Purpose and aim

Be able to create basic plots to explore your data.

## Loading data

If you haven't done so yet, please load the data as follows:

::: {.panel-tabset group="language"}
## R

```{r}
#| message: false
finches <- read_csv("data/finches.csv")
```

:::

## Building a plot

::: {.panel-tabset group="language"}
## R

Here we'll learn how to build a plot, using the `ggplot2` package. This package has a consistent set of grammer rules that allow you to create a plot. It needs 3 basic pieces of information:

- A **data.frame** with data to be plotted
- The variables (columns of `data.frame`) that will be _mapped_ to different 
**aesthetics** of the graph (e.g. axis, colours, shapes, etc.)
- the **geometry** that will be drawn on the graph (e.g. points, lines, 
boxplots, violinplots, etc.)

This translates into the following basic syntax:

``` r
ggplot(data = <data.frame>, 
       mapping = aes(x = <column of data.frame>,
                     y = <column of data.frame>)) +
   geom_<type of geometry>()
```


For our first visualisation, let's play around with our `finches` data.

The question we're interested in is: how much separation is there between 
the two finch species in terms of beak length and beak depth?

A [scatterplot](https://www.data-to-viz.com/graph/scatter.html)
showing the relationship between `bdepth` and `blength`. 

Let's do it step-by-step to see how `ggplot2` works. 
Start by giving data to `ggplot`:

```{r}
ggplot(data = finches)
```

That "worked" (as in, we didn't get an error). 
But because we didn't give `ggplot()` any variables to be _mapped_ to _aesthetic_ 
components of the graph, we just got an empty square. 

For **mappping columns to aesthetics**, we use the `aes()` function:

```{r}
ggplot(data = finches, 
       mapping = aes(x = bdepth,
                     y = blength))
```

That's better, now we have some axis. Notice how `ggplot()` defines the axis based 
on the range of data given. 
But it's still not a very interesting graph, because we didn't tell what it is we 
want to draw on the graph.

This is done by adding (literally `+`) **geometries** to our graph:

```{r}
ggplot(data = finches, 
       mapping = aes(x = bdepth,
                     y = blength)) +
  geom_point()
```

If you have any missing values then `geom_point()` will warn you that it had to remove some missing values. After all, if the data is missing for at least one of the variables, then it cannot plot the points.

:::

## Changing aesthetics
Let's say we're not very happy with the default options we have been given here. The colour of the data points isn't terribly exciting and there appears to be a bit of overlap as well.

We can define these attributes within `ggplot()`. For example, to change the colour of the data points we can do the following:

::: {.panel-tabset group="language"}
## R

```{r}
ggplot(data = finches, 
       mapping = aes(x = bdepth,
                     y = blength)) +
  geom_point(colour = "firebrick")
```
:::

To fix the issue with overlapping data points, we can change the level of transparency. This is set with the `alpha` argument, where `alpha = 1` is no transparency at all and `alpha = 0` is complete transparency. We'll pick something in between 0 and 1.

::: {.panel-tabset group="language"}
## R

```{r}
ggplot(data = finches, 
       mapping = aes(x = bdepth,
                     y = blength)) +
  geom_point(alpha = 0.6)
```
:::

## Changing aesthetics based on data

In the plot above we lumped all the data together. We've ignored the fact that these measurements come from two different species. These species are also subdivided into different groups. We'll explore the grouping later, but now we're interested to see if there are clear differences between the species.

A way to visualise this is by colouring the points based on a variable of interest, in our case `species`. 

::: {.panel-tabset group="language"}
## R

We can do this by passing this information to the `colour` aesthetic _inside_ the 
`aes()` function:

```{r}
#| warning: false
ggplot(data = finches, 
       mapping = aes(x = bdepth,
                     y = blength,
                     colour = species)) +
  geom_point()
```

::: {.callout-tip}
## Aesthetics: inside or outside `aes()`?

The previous examples illustrate an important distinction between _aesthetics_ defined inside or outside of `aes()`:

- if you want the _aesthetic_ to change **based on the data** it goes **inside `aes()`**
- if you want to **manually specify** how the geometry should look like, it goes **outside `aes()`**
:::

:::

## Multiple geometries

Often, we may want to overlay several geometries on top of each other. For example, we might want to visualise a box plot together with the data points.

Let's start by creating a plot that shows our data, split by `species`. In that case, `species` ends up on the x-axis, and the variable of interest is `blength` (beak length). This goes onto the y-axis.

That gives us the following:

::: {.panel-tabset group="language"}
## R

```{r}
#| warning: false
ggplot(finches, aes(x = species,
                    y = blength)) +
  geom_point()
```

To layer a boxplot on top of it we "add" (with `+`) another geometry to the graph:

```{r}
#| warning: false
ggplot(finches, aes(x = species,
                    y = blength)) +
  geom_point() +
  geom_boxplot()
```
:::

The order in which you add the geometries defines the order they are "drawn" on the graph. 
For example, try swapping their order and see what happens.

Notice how we've shortened our code by omitting the names of the 
options `data = ` and `mapping = ` inside `ggplot()`. Because the data is always 
the first thing given to `ggplot()` and the mapping is always identified by the 
function `aes()`, this is often written in the more compact form as we just did. 

## Key points

::: {.callout-note}

- We can build plots layer by layer
- Aesthetics can be based on data

:::
