{
  "hash": "abe5b73bc82826b6bd9b81aa3a3d2bc1",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Rank and order\"\n---\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n::: callout-tip\n## Learning outcomes\n\n- Consider informational hierarchy\n- Be able to rank and order data\n- Understand how to use ordering in visualisations\n:::\n\n## Libraries and functions\n\n::: {.callout-note collapse=\"true\"}\n## Click to expand\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n### Libraries\n### Functions\n\n:::\n:::\n\n## Purpose and aim\n\nHierarchy in data can often be translated to hierarchy of our graph. It allows us to change the narrative of our visualisation and give it structure. This often involves us ordering or ranking our data. We'll practice some examples of that here.\n\n## Loading data\n\nIf you haven't done so yet, please load the data as follows:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder <- read_csv(\"data/gapminder_clean.csv\")\n```\n:::\n\n\n:::\n\nUsing the `gapminder` data set, let's look at the following example.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](ranking_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n:::\n\nSo what happened here? Both plots show the average income across the countries within each world region. In panel A the different regions are **ordered** alphabetically, whereas in panel B they are displayed or **ranked** by average income.\n\nSame data, but a different purpose! When would we use one or the other?\n\nIf we simply wanted a look-up table, where we could easily find the average income for a specific world region, then we would want to use the representation in panel A. Let's say we want to find the value for South Asia - we'd follow along the x-axis in alphabetical order. Doing the same in panel B is actually much harder.\n\nIf we're interested in the world regions with particularly high average levels of income, then panel B would be more suitable. We'd simply look at the world regions that are displayed towards the right of the plot.\n\n## Reordering data\n\nThe process of reordering your data, depending on the purpose of your visualisation, can be a bit tricky.\n\nTo understand this a bit better it's important to get our head round some different categorical data types, wonderfully illustrated by [Allison Horst](https://github.com/allisonhorst):\n\n![](images/data-types.png)\n\nThe type we are focusing on is the **ordinal** data. These are descriptions (so not numerical data) that have some kind of order.\n\nThis can be an inherent order, for example a range of emotions from good to bad. Using the illustration we'd expect the bee to feel `awesome`, `ok` and `unhappy` in that order.\n\nIt can also be an order that we are imposing ourselves. Again, using the illustration we can talk about `turtle`, `snail` and `butterfly`. These have no inherent order, but maybe we want to impose one, such as alphabetical order. If we'd do that, they would be arranged as `butterfly`, `snail`, `turtle`.\n\nThe way that programming languages deal with this kind of ordering is through **factors**. These are categorical data that have a fixed and known set of values.\n\nLet's illustrate this with the bee example. Assume we followed a certain bee for 5 hours and recorded it emotional state once per hour. We could, hypothetically of course, end up with the following observations:\n\n`ok`, `awesome`, `unhappy`, `ok`, `unhappy`\n\nThe bee was clearly not having the best of days. But I digress.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nIf we wanted to code these states in R, then we would do the following:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbee <- c(\"ok\", \"awesome\", \"unhappy\", \"ok\", \"unhappy\")\n\nbee\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"ok\"      \"awesome\" \"unhappy\" \"ok\"      \"unhappy\"\n```\n\n\n:::\n:::\n\n\nThey appear in the order that I observed them. Now let's say that I want to impose a certain order on them, maybe alphabetically. I could take my `bee` object and convert it to a factor.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbee_factor <- factor(bee)\n\nbee_factor\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] ok      awesome unhappy ok      unhappy\nLevels: awesome ok unhappy\n```\n\n\n:::\n:::\n\n\nThe first line still gives me the 5 observations in their original order, but below it there are `Levels: awesome ok unhappy`.\n\nWhat's happened here is that R recognises that there are three distinct possible values in our data, `awesome`, `ok` and `unhappy`. And it's ordered them alphabetically, which is the default.\n\nIf I'd want to change this order, I can specify the levels directly:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfactor(bee_factor, levels = c(\"unhappy\", \"ok\", \"awesome\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] ok      awesome unhappy ok      unhappy\nLevels: unhappy ok awesome\n```\n\n\n:::\n:::\n\n:::\n\nNow let's see how we translate this to our data set. Let's create box plots for `income_per_person` for each main religion. We'll look at the default order, and then change it.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nIncome per person for each religion:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = gapminder,\n       aes(x = main_religion, y = income_per_person)) +\n  geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](ranking_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nThis is in alphabetical order, by default.\n\nLet's say we wanted to change it. One of the ways we could do this is by making the `main_religion` column a factor and changing its order. Let's say we wanted to arrange them in order of average income. We could find this out by calculating the average income for each religion:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder %>% \n  group_by(main_religion) %>% \n  summarise(mean_income = mean(income_per_person)) %>% \n  arrange(mean_income) %>% \n  ungroup()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 Ã— 2\n  main_religion     mean_income\n  <chr>                   <dbl>\n1 eastern religions      14034.\n2 muslim                 16600.\n3 christian              17721.\n```\n\n\n:::\n:::\n\n\nWe would then order the data as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder %>% \n  mutate(main_religion = factor(main_religion,\n                                levels = c(\"eastern religions\", \"muslim\", \"christian\"))) %>% \n  ggplot(aes(x = main_religion, y = income_per_person)) +\n  geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](ranking_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\nThis works, but you can imagine that if you have lots of groups then doing this by manually specifying the levels becomes very (very!) tedious.\n\nThankfully there is another way of doing exactly the same, without manual specifying the order. This uses the `fct_reorder()` function to... reorder the factor (what's in the name?!).\n\nThe way that it works is that you give it the data you want to reorder, then tell it what to reorder by. In our case we want to reorder by the mean income for each religion, so we need to calculate that first.  After that we reorder the data directly within `ggplot()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder %>% \n  # group by main religion\n  group_by(main_religion) %>% \n  # create a new column that contains the average\n  # income for that type of religion\n  mutate(mean_income = mean(income_per_person)) %>% \n  # remove the grouping\n  ungroup() %>% \n  # send the data to ggplot\n  # and fct_reorder the main_religion on the x-axis\n  # based on the calculated mean_income\n  ggplot(aes(x = fct_reorder(main_religion, mean_income),\n             y = income_per_person)) +\n  # create box plots\n  geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](ranking_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n:::\n\n## Stem plots\n\nThe bar plot was useful when there weren't too many observations. However, if we have lots of observations, then it can become a bit crowded. Have a look at the plot below, where we're looking at the income per person for all the countries in the Middle East / North Africa region:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder %>% \n  filter(world_region == \"middle_east_north_africa\") %>% \n  ggplot(aes(x = country, y = income_per_person)) +\n  geom_bar(stat = \"identity\") +\n  theme(axis.text.x = element_text(angle = 45, hjust=1))\n```\n\n::: {.cell-output-display}\n![](ranking_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n:::\n\nAnother way that we could display those data is by creating a stem plot (or lollipop plot).\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder %>% \n  filter(world_region == \"middle_east_north_africa\") %>% \n  ggplot(aes(x = country, y = income_per_person)) +\n  geom_point() +\n  geom_segment(aes(xend = country, yend = 0)) +\n  theme(axis.text.x = element_text(angle = 45, hjust=1))\n```\n\n::: {.cell-output-display}\n![](ranking_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n:::\n\nThis type of plot can be useful if you have lots of categories, since each category takes up a bit less space than a bar.\n\n### Exercises\n\n::: {.callout-note icon=\"false\"}\n## Reordering data FIXME\n\n**Level:** {{< fa solid star >}} {{< fa solid star >}} {{< fa regular star >}}\n\nBelow is a chunk of code. In several places the code states `<FIXME>`. Try to make the necessary changes, so that you end up with a stem plot that displays the number of children per woman, for each country in Europe and Central Asia. \nReorder the data by number of children per woman, from high to low.\n\nWhich country has the **second highest** number of children per woman?\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder %>% \n  filter(world_region == <FIXME>) %>% \n  ggplot(aes(x = fct_reorder(country,\n                             <FIXME>(children_per_woman)),\n             y = children_per_woman)) +\n  geom_point() +\n  geom_segment(aes(xend = <FIXME>, yend = 0)) +\n  theme(axis.text.x = element_text(angle = 45, hjust=1)) +\n  labs(x = \"Country\",\n       y = \"Children per woman\")\n```\n:::\n\n\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Answer\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder %>% \n  filter(world_region == \"europe_central_asia\") %>% \n  ggplot(aes(x = fct_reorder(country,\n                             desc(children_per_woman)),\n             y = children_per_woman)) +\n  geom_point() +\n  geom_segment(aes(xend = country, yend = 0)) +\n  theme(axis.text.x = element_text(angle = 45, hjust=1)) +\n  labs(x = \"Country\",\n       y = \"Children per woman\")\n```\n\n::: {.cell-output-display}\n![](ranking_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n:::\n\nThe country with the second highest number of children per woman is the Kyrgyz Republic (Kyrgyzstan).\n:::\n:::\n\n## Summary\n\n::: {.callout-tip}\n#### Key points\n\n- Ranking or ordering your data in a particular way can help tell a story\n- Programming languages use factors to deal with categories that have an inherent order\n\n:::\n",
    "supporting": [
      "ranking_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}