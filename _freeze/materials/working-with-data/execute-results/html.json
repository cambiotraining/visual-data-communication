{
  "hash": "56faef4aa49a19f03e2b45cf537612a3",
  "result": {
    "markdown": "---\ntitle: \"Working with data\"\n---\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n::: {.callout-tip}\n## Learning outcomes\n\n- Be able to import tabular data\n- Perform basic operations on data\n\n:::\n\n## Libraries and functions\n\n::: {.callout-note collapse=\"true\"}\n## Click to expand\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n### Libraries\n### Functions\n\n## Python\n\n### Libraries\n### Functions\n:::\n:::\n\n## Purpose and aim\n\nIn this section we're covering the basics of reading in using tabular data.\n\n## Gapminder data set\n\nWe will use data from the [_Gapminder Foundation_](https://www.gapminder.org/), \nwhich gives access to global data as well as many tools to help explore it.\nIn these lessons we're going to use some of these data to explore some of these data \nourselves.\n\nWe have two files with data relating to socio-economic statistics: world data \nfor 2010 only and the same data for 1960 to 2010.\n\nBoth of these have the same columns of data:\n\n| Column                       | Description                                                                                                                     |\n|-----------------------------|---------------------------------------------------------------------------------------------------------------------------------|\n| country                     | country name                                                                                                                    |\n| world_region                | 6 world regions                                                                                                                 |\n| year                        | year that each datapoint refers to                                                                                               |\n| children_per_woman          | total fertility rate                                                                                                            |\n| life_expectancy             | average number of years a newborn child would live if current mortality patterns were to stay the same                          |\n| income_per_person           | gross domestic product per person adjusted for differences in purchasing power                                                  |\n| is_oecd       | Whether a country belongs to the “OECD” (`TRUE`) or not (`FALSE`)                                                                                                       |\n| income_groups               | categorical classification of income groups                                                                                     |\n| population             | total number of a country's population                                                                                                 |\n| main_religion               | religion of the majority of population in 2008                                                                                  |\n| child_mortality             | death of children under 5 years old per 1000 births                                                                             |\n| life_expectancy_female      | life expectancy at birth, females                                                                                               |\n| life_expectancy_male        | life expectancy at birth, males                                                                                                 |\n\n## Reading in data\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nThere are several functions to read data into R, we're going to use one from the \n`readr` package, which is part of the `tidyverse`. As such, we first need to load \nthe package into R's memory, by using the `library()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\nThis command has to be run every time you start a new R session. Typically you \nwant to include the `library()` calls at the top of your script, so that a user \nknows which packages need to be installed to run the analysis.\n\nOur data is provided in CSV format (comma separated values). This format is a \nregular text file, where each value (or column of the table) is separated by a \ncomma. To read such a file, we use the `read_csv()` function, which needs at least \none input: the _path_ of the file we want to read. It is also good practice \nto explicitly define how missing data is encoded in the file with the `na` option. \nIn our case, missing data are encoded as an empty string (imagine this as an empty \ncell in a spreadsheet).\n\nHere's the command:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder <- read_csv(\"data/gapminder_clean.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 167 Columns: 13\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (4): country, world_region, income_groups, main_religion\ndbl (8): year, children_per_woman, life_expectancy, income_per_person, popul...\nlgl (1): is_oecd\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n:::\n\n\nWe see a lot of output there, but this is not an error! It's a message that `read_csv()` \nprints to inform us of what type of data it thinks each column of the data set is. \nWe'll discuss this in a while.\n\nIt's always useful to have a glimpse at the first few rows of your data set, to see how it is structured. We can do that with the `head()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(gapminder)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 13\n  country   world_region  year children_per_wo… life_expectancy income_per_pers…\n  <chr>     <chr>        <dbl>            <dbl>           <dbl>            <dbl>\n1 Afghanis… south_asia    2010             5.82            59.8             1672\n2 Angola    sub_saharan…  2010             6.16            59.9             6360\n3 Albania   europe_cent…  2010             1.65            77.6             9928\n4 United A… middle_east…  2010             1.87            72.9            55363\n5 Argentina america       2010             2.37            75.8            18912\n6 Armenia   europe_cent…  2010             1.55            74.0             6703\n# … with 7 more variables: is_oecd <lgl>, income_groups <chr>,\n#   population <dbl>, main_religion <chr>, child_mortality <dbl>,\n#   life_expectancy_female <dbl>, life_expectancy_male <dbl>\n```\n:::\n:::\n\n\n\n### The `data.frame` object\n\nA **data.frame** is the basic type of object that stores _tabular_ data. \nThe `readr` package reads data in an \"extended\" version of a data frame that it \ncalls **tibble** (`tbl` for short). The details of their differences are not very \nimportant unless you are a programmer, but _tibbles_ offer some user conveniences \nsuch as a better printing method. For the rest of the course we'll refer to \n\"data frames\" and \"tibbles\" interchangeably.\n\n\n## Python\n:::\n\n## Subsetting data\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nWe can subset the data in our `gapminder` table by **column** or **row**. The `tidyverse` package has a series of useful functions that allow you to do this.\n\n### Subsetting by column\n\nWe can use the `select()` function to select certain columns, for example if we just wanted the `country` and `year` column. The first argument we give to the function is the data set, followed by the name of the columns we want:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(gapminder, country, year)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 167 × 2\n   country               year\n   <chr>                <dbl>\n 1 Afghanistan           2010\n 2 Angola                2010\n 3 Albania               2010\n 4 United Arab Emirates  2010\n 5 Argentina             2010\n 6 Armenia               2010\n 7 Antigua and Barbuda   2010\n 8 Australia             2010\n 9 Austria               2010\n10 Azerbaijan            2010\n# … with 157 more rows\n```\n:::\n:::\n\n\n\n### Subsetting by row\n\nNow let's say we wanted to only keep certain observations - which are organised in rows. Here we can use the `filter()` function. For example, if we only wanted the data for the United Kingdom:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(gapminder, country == \"United Kingdom\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 13\n  country   world_region  year children_per_wo… life_expectancy income_per_pers…\n  <chr>     <chr>        <dbl>            <dbl>           <dbl>            <dbl>\n1 United K… europe_cent…  2010             1.89            80.4            36509\n# … with 7 more variables: is_oecd <lgl>, income_groups <chr>,\n#   population <dbl>, main_religion <chr>, child_mortality <dbl>,\n#   life_expectancy_female <dbl>, life_expectancy_male <dbl>\n```\n:::\n:::\n\n\nHere we've taken the `gapminder` data set and we asked R to give us the rows where `country == \"United Kingdom\"` is `TRUE`. It goes through all the rows, in this case checking the `country` column. If the statement `country == \"United Kingdom\"` is `TRUE`, it returns the row. Otherwise it doesn't.\n\nIn this case there is only one row with country \"United Kingdom\", but we could also use a different conditional statement, for example returning all the rows where the `income_per_person` is larger than $50,000:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(gapminder, income_per_person > 50000)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 8 × 13\n  country   world_region  year children_per_wo… life_expectancy income_per_pers…\n  <chr>     <chr>        <dbl>            <dbl>           <dbl>            <dbl>\n1 United A… middle_east…  2010             1.87            72.9            55363\n2 Brunei    east_asia_p…  2010             1.84            75.1            80556\n3 Switzerl… europe_cent…  2010             1.5             82.5            55866\n4 Kuwait    middle_east…  2010             2.22            81.2            75360\n5 Luxembou… europe_cent…  2010             1.58            80.8            91743\n6 Norway    europe_cent…  2010             1.95            80.9            62350\n7 Qatar     middle_east…  2010             2.07            78.0           119974\n8 Singapore east_asia_p…  2010             1.26            83.2            73061\n# … with 7 more variables: is_oecd <lgl>, income_groups <chr>,\n#   population <dbl>, main_religion <chr>, child_mortality <dbl>,\n#   life_expectancy_female <dbl>, life_expectancy_male <dbl>\n```\n:::\n:::\n\n\n## Python\n:::\n\n## Chaining commands\n\nSometimes we need to perform many different operations before we have the right data in the correct format that we need. For example, we might want to filter for certain values and then only keep certain columns. We could perform these operations one by one and save the output of each into an object that we then use for the next operation.\n\nBut this is not very efficient. So it can be useful to chain certain operations together, performing them one by one.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nIn R we can do this with the **pipe**. We'll be using the pipe operator for tidyverse (`%>%`). The pipe always starts with **data**, which it then \"pipes through\" to a function.\n\nLet's look at an example, recreating the `filter()` operation we did earlier, but this time with a pipe:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder %>% \n  filter(income_per_person > 50000)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 8 × 13\n  country   world_region  year children_per_wo… life_expectancy income_per_pers…\n  <chr>     <chr>        <dbl>            <dbl>           <dbl>            <dbl>\n1 United A… middle_east…  2010             1.87            72.9            55363\n2 Brunei    east_asia_p…  2010             1.84            75.1            80556\n3 Switzerl… europe_cent…  2010             1.5             82.5            55866\n4 Kuwait    middle_east…  2010             2.22            81.2            75360\n5 Luxembou… europe_cent…  2010             1.58            80.8            91743\n6 Norway    europe_cent…  2010             1.95            80.9            62350\n7 Qatar     middle_east…  2010             2.07            78.0           119974\n8 Singapore east_asia_p…  2010             1.26            83.2            73061\n# … with 7 more variables: is_oecd <lgl>, income_groups <chr>,\n#   population <dbl>, main_religion <chr>, child_mortality <dbl>,\n#   life_expectancy_female <dbl>, life_expectancy_male <dbl>\n```\n:::\n:::\n\n\nWhat it's done is taken the `gapminder` data set and then sent this to the `filter()` function. The function doesn't need the data set specified explicitly, because it knows it is coming from the pipe.\n\nWe can combine this with other functions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder %>% \n  filter(income_per_person > 50000) %>% \n  select(country, year)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 8 × 2\n  country               year\n  <chr>                <dbl>\n1 United Arab Emirates  2010\n2 Brunei                2010\n3 Switzerland           2010\n4 Kuwait                2010\n5 Luxembourg            2010\n6 Norway                2010\n7 Qatar                 2010\n8 Singapore             2010\n```\n:::\n:::\n\n\nHere we've performed the filtering, and then selected the `country` and `year` columns.\n## Python\n:::\n\nChaining operations can be a very powerful tool, since it allows you to break down a complex operation into smaller steps. This often makes the analysis a lot less daunting!\n\n## Key points\n\n::: {.callout-note}\n\n- Tabular data are an excellent format for programming languages\n- Having variables in columns and observations in rows makes analysis easier\n- We can subset data across columns and rows\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}