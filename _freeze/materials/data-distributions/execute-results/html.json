{
  "hash": "b63f4c13206f5a60f665043137443fd4",
  "result": {
    "markdown": "---\ntitle: \"Data distributions\"\n---\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n::: {.callout-tip}\n## Learning outcomes\n\n- Understand why we explore data distributions\n- Be able to visualise the structure of data\n- Use gained insight to explore further questions\n\n:::\n\n## Libraries and functions\n\n::: {.callout-note collapse=\"true\"}\n## Click to expand\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n### Libraries\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(visdat)\n```\n:::\n\n\n### Functions\n\n:::\n:::\n\n## Purpose and aim\n\nSometimes we're dealing with large data sets,  other times they might be small. Either way, gaining insight in how your data are distributed across the different variables will help you understand your data better. This is important, since it will affect how and which conclusions you may draw from your data at a later stage. In our case we're using the `gapminder` data set. This data set has 13 different variables, with observations for over 150 different countries in the year 2010.\n\nA good starting point of any analysis/exploration is to get a general sense of the **data structure**. Let's look into how we can do this.\n\n## Loading data\n\nIf you haven't done so yet, please load the data as follows:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfinches <- read_csv(\"data/finches.csv\")\n```\n:::\n\n\n:::\n\n## Data structure\n\nThere are different ways to gain insight into the structure of your data. You can do this numerically or visually.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nIn R we can use a package called `visdat` to visualise the structure of our data. If you haven't installed it yet, please run the following code in the console:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"visdat\")\n\n# load the package\nlibrary(visdat)\n```\n:::\n\n\nWe can then visualise our data structure with the `vis_dat()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvis_dat(finches)\n```\n\n::: {.cell-output-display}\n![](data-distributions_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nLooking at the y-axis, we can see that there are over 150 observations in this data set. The data are organised and coloured by type, with the column names (our variables) at the top.\n\nFrom this we can see that we have two character or text variables (`species` and `group`). There are also several numerical variables, such as `weight` and `wing`.\n\nThere is one variable which contains logical data (`TRUE/FALSE`), called `is_early`.\n\n:::\n\nThere is a wealth of data there! So where do we go from here? In this case we're going to use one of the variables as an example. We'll use `bdepth` (beak depth) to illustrate how you can get more insight into how certain parts of your data are distributed.\n\n## Box plots\n\nAn easy way to get a sense of the data distribution is to create a box plot. For the `bdepth` variable we can do this as follows:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = finches,\n       aes(x = 1,\n           y = bdepth)) +\n  geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](data-distributions_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\nSince we are plotting only one variable, we're defining the `x` value as 1, but it doesn't actually have any numerical meaning.\n\nBox plots give you some summary statistics, so therefore it's often useful to plot them together with the actual data. We can do this quite easily by adding another layer to the plot that contains the data points. We're also adding some transparency (`alpha = 0.4` - which is 40% opacity) so we can still see the box plots themselves. We're also defining the `width = 0.1` so that the data points are not spread out over the entire width of the box plot, but are constrained a bit more.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = finches,\n       aes(x = 1,\n           y = bdepth)) +\n  geom_boxplot() +\n  geom_jitter(alpha = 0.4, width = 0.1)\n```\n\n::: {.cell-output-display}\n![](data-distributions_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n:::\n\n## Violin plots\n\nViolin plots are similar to box plots, but they give extra information on the distribution of the data. This can be particularly useful if your data is multi-modal, as in, it has more than one peak.\n\nThis can happen if your data splits into two or more discernible groups.\n\nLet's say we wanted to look at the beak length across both species. Since we've got early and late time points it would not be fair to lump all the data together. So, let's focus on just the early observations. We can filter these out using the `is_early` variable.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nWe can use `geom_violin()` to create a violin plot in `ggplot2`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfinches %>% \n  filter(is_early == TRUE) %>% \n  ggplot(aes(x = species,\n             y = bdepth)) +\n  geom_violin()\n```\n\n::: {.cell-output-display}\n![](data-distributions_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n:::\n\nWe can see that in *G. fortis* the beak depth is more spread out than in *G. scandens* in these early observations (pre-1983). To illustrate this in more detail, we can overlay the actual data points - again avoiding overlap. We update our code as follows:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfinches %>% \n  filter(is_early == TRUE) %>% \n  ggplot(aes(x = species,\n           y = bdepth)) +\n  geom_violin() +\n  geom_jitter(width = 0.05,\n              alpha = 0.6)\n```\n\n::: {.cell-output-display}\n![](data-distributions_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n:::\n\n## Histograms\n\nAnother way to look at how data is distributed is to create a histogram. Here we slice our beak depth data into intervals and count how many observations fall into each interval. This gives us a frequency for the number of observations into each interval group.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nWe can do this quite straightforwardly by using `geom_histogram()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = finches,\n       aes(x = bdepth)) +\n  geom_histogram()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n:::\n\n::: {.cell-output-display}\n![](data-distributions_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\nWhen you run this bit of code it gives you some information:\n\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n\nWhat this means is that it chopped our data into 30 chunks/intervals and done the counting based on that. This might not be what we want and we can change this by changing the `bins` argument or using `binwidth`. The difference between the two is that with, for example, `bins = 5` we're saying \"chop the data into 5 equal chunks\" whereas with `binwidth = 5` we're saying \"chop the data into chunks of 5 millimeters each\".\n\nTo illustrate that histograms can vary heavily depending on the bin size, look at the following plots:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = finches,\n       aes(x = bdepth)) +\n  geom_histogram(bins = 5) +\n  labs(title = \"bins = 5\")\n```\n\n::: {.cell-output-display}\n![](data-distributions_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n\n```{.r .cell-code}\nggplot(data = finches,\n       aes(x = bdepth)) +\n  geom_histogram(bins = 15) +\n  labs(title = \"bins = 15\")\n```\n\n::: {.cell-output-display}\n![](data-distributions_files/figure-html/unnamed-chunk-12-2.png){width=672}\n:::\n:::\n\n\n:::\n\nThis means that our interpretation can also change, depending on the number of bins we've specified. So we need to be aware of this when we're using histograms!\n\nHowever we slice the data, a beak depth of around 9 mm appears to be most common.\n\n## Exercises\n\n### Late beak depth measurements {#sec-lateviolin}\n\n:::{.callout-exercise}\n\n\n{{< level 1 >}}\n\n\n\nWe've looked at the beak depth of the finches that were recorded before the 1983 event. I'd like you to do the same for the observations post-1983, using a violin plot. Plot the data by species.\n\n::: {.callout-answer collapse=true}\n## Answer\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfinches %>% \n  filter(is_early == FALSE) %>% \n  ggplot(aes(x = species,\n             y = bdepth)) +\n  geom_violin()\n```\n\n::: {.cell-output-display}\n![](data-distributions_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n:::\n:::\n:::\n\n### Beak depth over time {#sec-beakdepthtime}\n\n:::{.callout-exercise}\n\n\n{{< level 2 >}}\n\n\n\nIn the previous exercise we've plotted the beak depth values for the post-1983 finches, for each species as a violin plot. If you haven't done so yet, please plot them now and answer the following questions:\n\n1. Are there any clear visual differences between the early and late measurements?\n2. Depending on the answer in (1), is a violin plot the most appropriate type of plot? Explain why.\n\n::: {.callout-answer collapse=true}\n## Answer\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](data-distributions_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n:::\n\n1. The spread of the data in the early *G. scandens* data is much less than in the later observations. This suggests that the beak depth in this species was less variable before 1983. The spread in *G. fortis* seems relatively comparable between the two time points. But the violin is wider at the lower beak depth range in the later time point, compared to the early one. This suggests a reduction in the overall beak depth over time.\n\n2. The violin plot might not be the most suitable way of looking at these data. The width of the violins has information, but does make interpretation more complicated to the average reader.\n\nHow to improve? Well, I would start by looking at the actual data (see below). This seems to support the suggestion about the changes in *G. fortis*. If that's a message we would like to focus on we could represent the data as averages and highlight the changes. We'll practice this in the next exercise.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](data-distributions_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n:::\n:::\n\n### Changes in *G. fortis* beak depth {#sec-changesfortis}\n\n:::{.callout-exercise}\n\n\n{{< level 3 >}}\n\n\n\nIn @sec-beakdepthtime we saw that using a violin plot may not be the most appropriate method of displaying changes across the two time points. If we want to focus on the beak depth change in *G. fortis*, we could also plot the average value at each time point. If we connect these averages with a line, then we can visualise the *direction of change*. We'll cover this in more detail in a later chapter, but you can challenge yourself in advance! \n\nHints:\n\n* If you want to plot the average values, have a look at the `stat_summary()` function.\n* If you want to connect the means, Google for something along the lines of \"connect means using stat_summary\"\n* It's useful to plot the original data as well!\n\n::: {.callout-answer collapse=true}\n## Answer\n\nThere are actually quite a few steps to get the plot we'd like. Thankfully, using `ggplot()`, this is quite modular. So we'll do the following:\n\n1. Keep only the *G. fortis* data\n2. Plot the original data, perhaps adding some jitter/transparency to aid visual separation\n3. Calculate the mean value for each group (early/late) using `stat_summary()` and display this as a point\n4. Connect the two mean values. This is a bit trickier than it really ought to be, but in effect we need to tell `ggplot()` that the two mean values belong together. They do this through the `species` variable, since they both come from the same species.\n5. Change the colour of the points/line of the averages to stand out from the original data\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfinches %>% \n  filter(species == \"G. fortis\") %>% \n  ggplot(aes(x = is_early,\n             y = bdepth)) +\n  geom_jitter(width = 0.05,\n              alpha = 0.6) +\n  stat_summary(fun = mean,\n               geom = \"point\",\n               size = 3,\n               colour = \"firebrick\") +\n  stat_summary(aes(group = species), fun = mean,\n               geom = \"line\",\n               linewidth = 1,\n               colour = \"firebrick\")\n```\n\n::: {.cell-output-display}\n![](data-distributions_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n:::\n\nWe can see that, on average, the beak depth is lower in the post-1983 measurements (`is_early = FALSE`). This is further emphasised through connecting the two averages: the slope of the line indicates the difference between them.\n\nI would personally prefer to see the early data on the left, and the later data on the right. That makes more sense chronologically. That is indeed possible, but includes something called `factors`, which we'll cover later. So for now, we won't worry about it.\n:::\n:::\n\n## Key points\n\n::: {.callout-note}\n\n- Data distributions allows us to understand the structure of our data better\n- Box and violin plots give us summary statistics\n- Histograms displays the frequency of observations\n- Once you have a story to tell (or point to make), revisit your plots and choose the most appropriate one to convey that\n:::\n",
    "supporting": [
      "data-distributions_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}