{
  "hash": "9571e66fa3b74a2f023e041b2c62631c",
  "result": {
    "markdown": "---\ntitle: \"Introduction to plotting\"\n---\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n::: {.callout-tip}\n## Learning outcomes\n\n- Be able to create basic plots\n\n:::\n\n## Libraries and functions\n\n::: {.callout-note collapse=\"true\"}\n## Click to expand\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n### Libraries\n### Functions\n\n## Python\n\n### Libraries\n### Functions\n:::\n:::\n\n## Purpose and aim\n\nBe able to create basic plots to explore your data.\n\n## Loading data\n\nIf you haven't done so yet, please load the data as follows:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder <- read_csv(\"data/gapminder_clean.csv\")\n```\n:::\n\n\n## Python\n:::\n\n## Building a plot\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nHere we'll learn how to build a plot, using the `ggplot2` package. This package has a consistent set of grammer rules that allow you to create a plot. It needs 3 basic pieces of information:\n\n- A **data.frame** with data to be plotted\n- The variables (columns of `data.frame`) that will be _mapped_ to different \n**aesthetics** of the graph (e.g. axis, colours, shapes, etc.)\n- the **geometry** that will be drawn on the graph (e.g. points, lines, \nboxplots, violinplots, etc.)\n\nThis translates into the following basic syntax:\n\n``` r\nggplot(data = <data.frame>, \n       mapping = aes(x = <column of data.frame>, y = <column of data.frame>)) +\n   geom_<type of geometry>()\n```\n\n\nFor our first visualisation, let's try to recreate one of the visualisations \nfrom [Hans Rosling's talk](https://www.ted.com/talks/hans_rosling_shows_the_best_stats_you_ve_ever_seen?utm_campaign=tedspread&utm_medium=referral&utm_source=tedcomshare).\nThe question we're interested in is: how much separation is there between \ndifferent world regions in terms of family size and life expectancy? \nWe will explore this by using a [scatterplot](https://www.data-to-viz.com/graph/scatter.html)\nshowing the relationship between `children_per_woman` and `life_expectancy`. \n\nLet's do it step-by-step to see how `ggplot2` works. \nStart by giving data to `ggplot`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = gapminder)\n```\n\n::: {.cell-output-display}\n![](intro-to-plotting_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nThat \"worked\" (as in, we didn't get an error). \nBut because we didn't give `ggplot()` any variables to be _mapped_ to _aesthetic_ \ncomponents of the graph, we just got an empty square. \n\nFor **mappping columns to aesthetics**, we use the `aes()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = gapminder, \n       mapping = aes(x = children_per_woman, y = life_expectancy))\n```\n\n::: {.cell-output-display}\n![](intro-to-plotting_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nThat's better, now we have some axis. Notice how `ggplot()` defines the axis based \non the range of data given. \nBut it's still not a very interesting graph, because we didn't tell what it is we \nwant to draw on the graph.\n\nThis is done by adding (literally `+`) **geometries** to our graph:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = gapminder, \n       mapping = aes(x = children_per_woman, y = life_expectancy)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](intro-to-plotting_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nNotice how `geom_point()` warns you that it had to remove some missing values\n(if the data is missing for at least one of the variables, then it cannot plot \nthe points).\n\n## Python\n:::\n\n## Changing aesthetics based on data\n\nIn the above exercise we changed the colour of the points by defining it ourselves. \nHowever, it would be better if we coloured the points based on a variable of interest. \n\nFor example, to explore our question of how different world regions really are, \nwe want to colour the countries in our graph accordingly. \n\n::: {.panel-tabset group=\"language\"}\n## R\n\nWe can do this by passing this information to the `colour` aesthetic _inside_ the \n`aes()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = gapminder, \n       mapping = aes(x = children_per_woman, y = life_expectancy, colour = world_region)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](intro-to-plotting_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n::: {.callout-tip}\n## Aesthetics: inside or outside `aes()`?\n\nThe previous examples illustrate an important distinction between _aesthetics_ defined inside or outside of `aes()`:\n\n- if you want the _aesthetic_ to change **based on the data** it goes **inside `aes()`**\n- if you want to **manually specify** how the geometry should look like, it goes **outside `aes()`**\n:::\n\n## Python\n:::\n\n## Multiple geometries\n\nOften, we may want to overlay several geometries on top of each other. For example, we might want to visualise a box plot together with a violin plot.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nLet's start by making a violin plot:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# scale the violins by \"width\" rather than \"area\", which is the default\nggplot(gapminder, aes(x = world_region, y = children_per_woman)) +\n  geom_violin(scale = \"width\")\n```\n\n::: {.cell-output-display}\n![](intro-to-plotting_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\nTo layer a boxplot on top of it we \"add\" (with `+`) another geometry to the graph:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Make boxplots thinner so the shape of the violins is visible\nggplot(gapminder, aes(x = world_region, y = children_per_woman)) +\n  geom_violin(scale = \"width\") +\n  geom_boxplot(width = 0.2)\n```\n\n::: {.cell-output-display}\n![](intro-to-plotting_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nThe order in which you add the geometries defines the order they are \"drawn\" on the graph. \nFor example, try swapping their order and see what happens.\n\nNotice how we've shortened our code by omitting the names of the \noptions `data = ` and `mapping = ` inside `ggplot()`. Because the data is always \nthe first thing given to `ggplot()` and the mapping is always identified by the \nfunction `aes()`, this is often written in the more compact form as we just did. \n\n## Python\n:::\n\n## Key points\n\n::: {.callout-note}\n\n- We can build plots layer by layer\n- Aesthetics can be based on data\n\n:::\n",
    "supporting": [
      "intro-to-plotting_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}