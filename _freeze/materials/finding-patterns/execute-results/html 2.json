{
  "hash": "bf3cd80d0feb8cfc346853b7937ee42a",
  "result": {
    "markdown": "---\ntitle: \"Finding patterns\"\n---\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n::: {.callout-tip}\n## Learning outcomes\n\n**Questions**\n\n-\n-\n\n**Objectives**\n\n-\n-\n-\n:::\n\n## Libraries and functions\n\n::: {.callout-note collapse=\"true\"}\n## Click to expand\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n### Libraries\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(visdat)\n```\n:::\n\n\n### Functions\n\n## Python\n\n### Libraries\n### Functions\n:::\n:::\n\n## Finding patterns\n\nWhen we set off to gather or explore data, we generally have a research question that we're interested in. We then design an experiment to test this question - in that case our data helps us to find an answer.\n\nQuite often we gather a lot more data than we directly need to answer our research question. As such, it's often very useful to explore our data and look for patterns.\n\nBy doing this we can get insight into any trends that might exist in the data, or distributions across the data. We can also look for correlation between different variables (things we've measured) or make comparisons between different groups.\n\n### Loading data\n\nThe first step to exploring our data is of course loading it in the first place.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder <- read_csv(\"data/gapminder_clean.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 167 Columns: 13\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (4): country, world_region, income_groups, main_religion\ndbl (8): year, children_per_woman, life_expectancy, income_per_person, popul...\nlgl (1): is_oecd\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n:::\n\n\n## Python\n:::\n\nThe `gapminder` data set that we've loaded has 13 different variables, with observations for over 150 different countries in the year 2010.\n\n### Data structure\n\nSometimes we're dealing with rather large data sets, whereas other times it might be small. A good starting point of any analysis/exploration is to get a broad overview of how our data is structured.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nIn R we can use a package called `visdat` to visualise the structure of our data. If you haven't installed it yet, please run the following code in the console:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"visdat\")\n```\n:::\n\n\nWe can then visualise our data structure with the `vis_dat()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvis_dat(gapminder)\n```\n\n::: {.cell-output-display}\n![](finding-patterns_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\nLooking at the y-axis, we can see that there are over 150 observations in this data set. The data are organised and coloured by type, with the column names (our variables) at the top.\n\nFrom this we can see that we have several character or text variables (e.g. `country`, `world_region`). There are also several numerical variables, such as `year` and `children_per_woman`.\n\nThere is one variable which contains logical data (`TRUE/FALSE`), called `is_oecd`.\n\n## Python\n:::\n\nThere is a wealth of data there! To illustrate how we can use different visualisations to look at the same variable, we're going to focus on `life_expectancy` in different contexts.\n\nLet's start off with a simple scatter plot that looks at `life_expectancy` against `income_per_person`:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = gapminder,\n       aes(x = income_per_person,\n           y = life_expectancy)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](finding-patterns_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n## Python\n:::\n\nIt seems that as the income per person increases, so does the life expectancy. We can also see that the life expectancy kind of plateaus - which is not very surprising, since it can't go on indefinitely!\n\nLooking at this plot, it's quite striking how there is quite a range of life expectancy values at the really low income countries. There is information on different world regions in the data (`world_region`). Perhaps there are certain world regions that have particularly low income levels?\n\nThis is something we can easily check.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nWe simply adjust the previous plot by colouring our data by `world_region`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = gapminder,\n       aes(x = income_per_person,\n           y = life_expectancy,\n           colour = world_region)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](finding-patterns_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n## Python\n:::\n\nLooking at this plot it appears that most of the low-income countries are in sub-Saharan Africa.\n\n### Distributions\n\nWe've looked at some patterns in our data, using the `life_expectancy` variable as an example.\n\nWe might want to understand this variable a bit better, so we need to look at it a bit more closely. A way of doing this is to see how life expectancy is distributed. We already noticed that life expectancy levels off, but perhaps there is more in these data than we already know.\n\nAn easy way to get a sense of how your data are distributed is to create a box plot:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = gapminder,\n       aes(y = life_expectancy)) +\n  geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](finding-patterns_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\n## Python\n:::\n\nAnother way is to create a histogram, where we slice our data into intervals (for example, in 5 year chunks e.g. 35-40 years, 40-45 years etc) and count how many observations fall into each interval.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nWe can do this quite straightforwardly by using `geom_histogram()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = gapminder,\n       aes(x = life_expectancy)) +\n  geom_histogram()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n:::\n\n::: {.cell-output-display}\n![](finding-patterns_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\nWhen you run this bit of code it gives you some information:\n\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n\nWhat this means is that it chopped our data into 30 chunks/intervals and done the counting based on that. This might not be what we want and we can change this by changing the `bins` argument or using `binwidth`. The difference between the two is that with, for example, `bins = 10` we're saying \"chop the data into 10 equal chunks\" whereas with `binwidth = 10` we're saying \"chop the data into chunks of 10 years each\".\n\nTo illustrate that histograms can vary heavily depending on the bin size, look at the following plots:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = gapminder,\n       aes(x = life_expectancy)) +\n  geom_histogram(bins = 5) +\n  labs(title = \"bins = 5\")\n```\n\n::: {.cell-output-display}\n![](finding-patterns_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n\n```{.r .cell-code}\nggplot(data = gapminder,\n       aes(x = life_expectancy)) +\n  geom_histogram(bins = 15) +\n  labs(title = \"bins = 15\")\n```\n\n::: {.cell-output-display}\n![](finding-patterns_files/figure-html/unnamed-chunk-12-2.png){width=672}\n:::\n:::\n\n\n## Python\n:::\n\nHowever we slice the data, the largest number of countries with similar life expectancy seem to be in the 70-80 year range.\n\nThere is also one country where life expectancy is very low and if I'd see a plot like this I would definitely want to investigate that further!\n\n\n## Exercise\n\n::: {.callout-tip collapse=\"true\"}\n## Answer\n::: {.panel-tabset group=\"language\"}\n## R\n## Python\n:::\n:::\n\n## Key points\n\n::: {.callout-note}\n-\n-\n-\n:::\n",
    "supporting": [
      "finding-patterns_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}