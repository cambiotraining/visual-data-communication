{
  "hash": "03d394e5f92ebacc2aadec78a36153fc",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Functions and objects\"\n---\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n::: {.callout-tip}\n## Learning outcomes\n\n- Be able to use functions\n- Be able to assign values to objects\n\n:::\n\n## Purpose and aim\n\nIn this section we'll focus on functions and objects. We'll learn how to use functions and how to create and access objects.\n\n## Functions\n\nFunctions perform specific operations. A function usually gets one or more inputs called arguments and returns a value. You can see it as a predefined script.\n\nAn example is:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt()\n```\n:::\n\n\nThis function returns the square root of a number. As such, it can only have a number as input, for example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(9)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\n:::\n\nFunctions can take different **arguments**. In the example above there was only one, but many functions allow you to specify more than one input. For example, let's say we wanted to round a number.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nWe can use the `round()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(10.232)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n:::\n\n\nThis returns a whole number. But what if we wanted to round it to one decimal? The `round()` function has an argument called `digits` that allows you to do just that. We separate the input and the argument with a comma.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(10.232, digits = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10.2\n```\n\n\n:::\n:::\n\n\n:::\n\n## Objects\n\nOften, you want to save the output of an operation for later use. In those cases we need to store that information somewhere. These are called **objects**. What happens is that we **assign** the output of the operation to an object.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nTo create an object, we need to give it a name followed by the assignment operator `<-`, and the value we want to give to it.\n\nFor example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage <- 21\n```\n:::\n\n\nWe can read the code as: the value 21 is assigned to the object `age`. When you run this line of code the object you just created appears in your `Environment` tab (top-right panel).\n\nWhen assigning a value to an object, R does not print anything on the console. You can print the value by typing the object name in the console or by running it from within your script.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 21\n```\n\n\n:::\n:::\n\n\n:::\n\n### Using objects\n\nThe nice thing about storing values in objects is that you can use them for further operations. Look at the following example.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nLet's say we wanted to calculate double the `age`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage * 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 42\n```\n\n\n:::\n:::\n\n\nWe can also perform operations between variables:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nphd_length <- 4\n\nage + phd_length\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 25\n```\n\n\n:::\n:::\n\n\n:::\n\n:::{.callout-important}\n## Exercise\nComplete [Exercise -@sec-exr_objects].\n:::\n\n### Object types\n\nIn the example above we only used numbers - these are very useful, since we can do calculations with them.\n\nNumbers are just one type of data you may encounter. Although there are quite a few different types, the main ones include:\n\n1. numbers (e.g. `62`, `55`, `-27`)\n2. text (e.g. `\"bunny\"`, `\"greenhouse\"`, `\"binder\"`)\n3. logical (`TRUE` or `FALSE`)\n4. missing values (`NA`)\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nYou might have noticed that the text values are in quotes (`\" \"`). R requires all text to be within quotation marks. That's the way it recognises it as text (also sometimes referred to as a *string*).\n\nThe logical values are binary: they're either true or false. In R these true/false designations are represented by `TRUE` and `FALSE`. Note that they are case-sensitive.\n\nMissing values are specifically encoded as such in R. You'll find that this is a really useful feature, because it makes missing values explicit. They are encoded with `NA`.\n\n:::{.callout-note}\n## Special meanining\n\nYou will notice that, in RStudio, the `TRUE`, `FALSE` and `NA` values are coloured light blue. This is because they have special meaning to R.\n\nThis also means that we shouldn't use these in different context. For example, it's a bad idea to create an object named `TRUE`, since it would really confuse R.\n\nThere are other names that have special meaning, but don't worry too much about it for now. Generally, if you accidentally choose a name for an object that has special meaning, it'll quickly becomes clear because your code might stop working.\n\n:::\n:::\n\n### Vectors\n\nVectors are the building block of most programming languages. They are containers for a sequence of data elements. That may sound a bit cryptic, so let's illustrate this with some examples.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nIn the examples above we stored a single value in an object. But quite often we work with more than just one data point. The way that we group these together into a vector is by using the `c()` function.\n\nThe `c()` or concatenate / combine function does what it says on the tin: it combines multiple values together. Have a look at the following set of examples:\n\n**Numbers:**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_num <- c(12, 22, 98, 61)\n\nvec_num\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12 22 98 61\n```\n\n\n:::\n:::\n\n\n**Text:**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_text <- c(\"felsic\", \"intermediate\", \"mafic\", \"ultramafic\")\n\nvec_text\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"felsic\"       \"intermediate\" \"mafic\"        \"ultramafic\"  \n```\n\n\n:::\n:::\n\n\nIn case you are wondering, these are [different types of lava](https://en.wikipedia.org/wiki/Lava#:~:text=Because%20of%20the%20role%20of,intermediate%2C%20mafic%2C%20and%20ultramafic.).\n\n**Mixed types:**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_mixed <- c(\"tree\", \"leaf\", 31, NA, 22)\n\nvec_mixed\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"tree\" \"leaf\" \"31\"   NA     \"22\"  \n```\n\n\n:::\n:::\n\n:::\n\nYou can also combine vectors together, for example:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(vec_num, vec_mixed)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"12\"   \"22\"   \"98\"   \"61\"   \"tree\" \"leaf\" \"31\"   NA     \"22\"  \n```\n\n\n:::\n:::\n\n\n:::\n\n:::{.callout-note}\n## Preferential treatment\nOften, not all data types are equal. We won't go into too much detail here, but it's important to keep in mind that:\n\n* presence of text in a vector often leads to *all* the elements being converted to text\n:::\n\n:::{.callout-important}\n## Exercise\nComplete [Exercise -@sec-exr_vectors].\n:::\n\n## Exercises\n\n### Dealing with objects {#sec-exr_objects}\n\n:::{.callout-exercise}\n\n\n{{< level 1 >}}\n\n\n\n* Create an object `day_temp` containing the current temperature (yes, you can guess!)\n* Create an object `weather` containing the values `raining`, `cloudy`, `sunny`\n\n::: {.callout-answer collapse=true}\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nday_temp <- 21\n\nweather <- c(\"raining\", \"cloudy\", \"sunny\")\n```\n:::\n\n\n:::\n:::\n:::\n\n### Vectors {#sec-exr_vectors}\n\n:::{.callout-exercise}\n\n\n{{< level 1 >}}\n\n\n\nCreate the following vectors:\n\n1. A vector `vec_1` containing 3 numbers\n2. A vector `vec_2` with two numbers and two words\n3. A vector `vec_3` with two numbers, a missing value, two words and a TRUE/FALSE outcome \n\nLook at the content of the vectors. Is there anything you notice?\n\n::: {.callout-answer collapse=true}\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_1 <- c(31, 8, 92)\n\nvec_2 <- c(77, \"hedgehog\", \"cloud\", 33)\n\nvec_3 <- c(23, 66, NA, \"bob\", \"jeff\", FALSE)\n```\n:::\n\n\nYou might have noticed that in `vec_2` and `vec_3` every value is now within quotes. That's because as soon as there is any text in a vector, R automatically converts *all* elements in the vector to text.\n:::\n:::\n:::\n\n## Summary\n\n::: {.callout-tip}\n#### Key points\n\n- Functions perform a specific set of operations\n- Objects allow you to store value that can be accessed later\n:::\n",
    "supporting": [
      "functions-and-objects_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}