{
  "hash": "b8a04d646215f3daba25e7fc09ad01cf",
  "result": {
    "markdown": "---\ntitle: \"Functions and objects\"\n---\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n::: {.callout-tip}\n## Learning outcomes\n\n- Be able to use functions\n- Be able to assign values to objects\n\n:::\n\n## Libraries and functions\n\n::: {.callout-note collapse=\"true\"}\n## Click to expand\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n### Libraries\n### Functions\n:::\n:::\n\n## Purpose and aim\n\nIn this section we'll focus on functions and objects. We'll learn how to use functions and how to create and access objects.\n\n## Functions\n\nFunctions perform specific operations. A function usually gets one or more inputs called arguments and returns a value. An example is:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt()\n```\n:::\n\n\nThis function returns the square root of a number. As such, it can only have a number as input, for example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(9)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\n:::\n\nFunctions can take different arguments. In the example above there was only one, but many functions allow you to specify more than one input. For example, let's say we wanted to round a number.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nWe can use the `round()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(10.232)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n:::\n\n\nThis returns a whole number. But what if we wanted to round it to one decimal? The `round()` function has an argument called `digits` that allows you to do just that. We separate the input and the argument with a comma.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(10.232, digits = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10.2\n```\n:::\n:::\n\n\n:::\n\n## Objects\n\nOften, you want to save the output of an operation for later use. In other words, we need to assign values to objects.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nTo create an object, we need to give it a name followed by the assignment operator `<-`, and the value we want to give to it.\n\nFor example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage <- 32\n```\n:::\n\n\nWe can read the code as: the value 32 is assigned to the object `age`. Note that when you run this line of code the object you just created appears on your environment tab (top-right panel).\n\nWhen assigning a value to an object, R does not print anything on the console. You can print the value by typing the object name on the console:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 32\n```\n:::\n:::\n\n\n:::\n\n### Using objects\n\nThe nice thing about storing values in objects is that you can use them for further operations. Look at the following example.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nLet's say we wanted to calculate double the `age`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage * 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 64\n```\n:::\n:::\n\n\n:::\n\n## Key points\n\n::: {.callout-note}\n\n- Functions perform a specific set of operations\n- Objects allow you to store value that can be accessed later\n:::\n",
    "supporting": [
      "functions-and-objects_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}